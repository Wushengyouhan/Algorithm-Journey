# 1. 字符串的全部子序列
https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a

1. 递归出口，当 i 等于 s的长度时。
2. 用path保存当前的路径。

# 2. 子集 II
https://leetcode.cn/problems/subsets-ii/description/

1. 先排序
2. 递归前先剪枝 

```
对重复元素剪纸，包含0,1,2,3..个。 再进行后续的递归
[1,1,1,2,2,3]
```

# 3. 全排列
https://leetcode.cn/problems/permutations/

1. 依次把后面的数换到当前位置i
2. 对下一个位置 i+1，进行递归排列
3. 当 i === length 时记录结果
4. 注意要恢复现场，把值交换回去
  
# 4. 全排列 II
https://leetcode.cn/problems/permutations-ii/

1. 这题不同之处在于包含重复数字
2. 每个递归中，遇到一个位置放过a数字，后面再碰到该位置是a时，就可以不考虑了。
3. 方法是每个递归创建一个set，放过i位置的数字就记录一下

# 5.用递归逆序栈

1. bottomOut里 每个递归的ans可以保存自己本次弹出的栈顶
2. 而last，就是栈底元素，可以从下面一直被带着返回到最外面
```
以栈 [5, 4, 3, 2, 1] 为例，我们调用 bottomOut(stack)。

递归深入的过程：
每次调用都会弹出栈顶元素，递归继续深入。

第一次递归：
栈为 [5, 4, 3, 2, 1]。
弹出 5，ans = 5。
递归调用 bottomOut([4, 3, 2, 1])。

第二次递归：
栈为 [4, 3, 2, 1]。
弹出 4，ans = 4。
递归调用 bottomOut([3, 2, 1])。

第三次递归：
栈为 [3, 2, 1]。
弹出 3，ans = 3。
递归调用 bottomOut([2, 1])。

第四次递归：
栈为 [2, 1]。
弹出 2，ans = 2。
递归调用 bottomOut([1])。

第五次递归（基准条件）：
栈为 [1]。
弹出 1，ans = 1。
栈为空，返回 1（last = 1）。
递归回溯的过程：
每次返回时，恢复之前弹出的元素，同时将 last 继续向上传递。

从第五次递归返回：
返回 last = 1。
此时栈为空，ans = 2（之前弹出的 2）。
将 2 压回栈：stack.push(2)。
栈变为 [2]。

从第四次递归返回：
返回 last = 1。
此时栈为 [2]，ans = 3（之前弹出的 3）。
将 3 压回栈：stack.push(3)。
栈变为 [2, 3]。

从第三次递归返回：
返回 last = 1。
此时栈为 [2, 3]，ans = 4（之前弹出的 4）。
将 4 压回栈：stack.push(4)。
栈变为 [2, 3, 4]。

从第二次递归返回：
返回 last = 1。
此时栈为 [2, 3, 4]，ans = 5（之前弹出的 5）。
将 5 压回栈：stack.push(5)。
栈变为 [2, 3, 4, 5]。
```

3. num保存的是每次reverse的栈底
4. 到栈为空之后，开始回溯，5是最后出的栈底，所以先推进去

# 6. 用递归排序栈

## 要求
- 请完成无序栈的排序，要求排完序之后，从栈顶到栈底从小到大
- 只能使用栈提供的push、pop 2个方法、以及递归函数
- 除此之外不能使用任何的容器，数组也不行

1. 需要4个辅助函数，这些函数都不能破坏栈的结构 
```
返回栈的深度
不改变栈的数据状况

从栈当前的顶部开始，往下数deep层
返回这deep层里的最大值

从栈当前的顶部开始，往下数deep层，已知最大值是max了
返回，max出现了几次，不改变栈的数据状况

从栈当前的顶部开始，往下数deep层，已知最大值是max，出现了k次
请把这k个最大值沉底，剩下的数据状况不变
```

2. 主函数用个while循环，每次处理k个相等的的max。


# 7. 汉诺塔
1. 要有抽象思维
2. f(i, from, to, other)