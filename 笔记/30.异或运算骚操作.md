# 异或
## 核心
1. 异或的核心是不进位相加
2. 异或公式
```js
//一个数异或自己等于0
a^a = 0
//异或0等于本身
a^0 = a
//结合律
a^b^c = a^(b^c)
//交换律
a^b = b^a
//整体异或和如果是c，整体中某个部分的异或和如果是b，那么剩下部分的异或和是b^c
a^b=c
a=c^b
```

## 题目
### 1.交换两个数
数组中不同位置交换才可以，所以不推荐

### 2.不用任何判断语句和比较操作，返回两个数的最大值
https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76


提取最右侧1的算法:
1. 取反+1，就是自己的相反数
2. 与上自己
```javascript
 n & -n
```

### 3.丢失的数字
https://leetcode.cn/problems/missing-number/

### 4.出现奇数次的数
https://leetcode.cn/problems/single-number/description/

数组中1种数出现了奇数次，其他的数都出现了偶数次，返回出现了奇数次的数

偶数次的数异或都会抵消，最后剩的一个就是奇数次的那个数

### 5.出现奇数次的数2
https://leetcode.cn/problems/single-number-iii/description/

数组中有2种数出现了奇数次，其他的数都出现了偶数次，返回这2种出现了奇数次的数

假设最后剩的两个数是a，b是3和5

- 3:0011
- 5:0101
- eor1 = 3^5: 0110
- 提取最右侧的1: 0010。
那么这两个数在这一位上，必然有一个是1，另一个不是1，不信你看3和5.这个条件可以把原来数据划分成2波。
一波含a和其他数，一波含b和其他数。这样就可以变成了问题4了。

### 6.出现次数小于m次的数 
https://leetcode.cn/problems/single-number-ii/

数组中只有1种数出现次数少于m次，其他数都出现了m次
返回出现次数小于m次的那种数

#### 思路
先统计每一位上1的个数
若某位1的个数不是m的倍数，说明收到那那个数字的干扰，就把ans的该位置成1
```
0010
0010
0010
1000
1100
1100
1100

4 3 3 0
```

最高位是4，不是3的倍数,所以ans的最高位也是1