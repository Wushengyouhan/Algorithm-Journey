# 1.2的幂
https://leetcode.cn/problems/power-of-two/description/

# 2.3的幂
https://leetcode.cn/problems/power-of-three/description/

1. 先求出32位有符号里3的最大幂是多少。
2. 看 ```n > 0 && 最大数 % n === 0```

# 3.大于等于n最小的2次幂
已知n是非负数
返回大于等于n的最小的2某次方
如果int范围内不存在这样的数，返回整数最小值

## 核心算法
把低位都刷成1，最后再+1
注意一开始就是2的幂次的情况，所以n先减1

# 4.数字范围按位与
https://leetcode.cn/problems/bitwise-and-of-numbers-range/

本质: 找公共高位
## 核心算法
1. right每次减掉最右侧的1(right -= right&(-right))
2. 如果大于left就继续, 小与等于left就停止



比如求[9,15]范围内按位与
8  -> 00001000
9  -> 00001001
10 -> 00001010
11 -> 00001011
12 -> 00001100
13 -> 00001101
14 -> 00001110
15 -> 00001111

1. 起始状态: right = 00001111
2. 去掉最右侧1: right -> 00001110, 此时 > 最小值9, 说明right - 1 必然存在，该例中就是13存在，这进行与运算之后造成,最小位的1变成0，留不下来
3. 继续去掉最右侧1: right -> 00001100, 同上。
4. 继续: right -> 00001000, 此时 < 9, 说明前缀是00001XXX, 而后面的三位又留不下来，所以此时的right就是结果

# 5. 颠倒二进制位
https://leetcode.cn/problems/reverse-bits/description/

按位分治，先两两交换，再4个4个换，再8个8个换，再16个16个换
```
n =   10111001
&aa   10101010
      10101000
>>>1   01010100 

n =   10111001
&55   01010101
      00010001
<<1   00100010

      01010100
|     00100010
      01110110

4个交换： 11011001

      
```

1. 右移的时候要使用无符号右移 >>>
2. 返回结果n的时候要 n >>> 0转成无符号

# 6.汉明距离

https://leetcode.cn/problems/hamming-distance/description/

## 核心算法

1. 先异或得到n
2. 统计n里有多少个1

## 统计n里有多少个1

把1挤到后面，然后统计个数

```
n     10110011
&55   01010101
      00010001

n>>>1 01011001
&55   01010101
      01010001

      00010001
+     01010001
      01100010       //此时保存的就是2位上1的数量

======================================
n     01100010
&33   00110011
      00100010

n>>>2 00011000
&33   00110011
      00010000

      00100010
+     00010000
      00110010      //每4位有几个1

=======================================

n     00110010
&0f   00001111
      00000010

n>>>4 00000011
&0f   00001111
      00000011

      00000010
+     00000011
      00000101    //8位上有几个1  

=========================================

16位上就 n>>>8     &00ff00ff
32上就  n>>>16     &0000ffff


```




